#!/usr/bin/env sh
#

# BSD 2-Clause License
# 
# Copyright (c) 2023, Justin Teague
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# rssntfy -- send notifications to ntfy.sh service when an rss feed updates

set -eu

LC_ALL=C

Prgnam="$(basename "$0")"
Version=0.0.1
Verbose=0
Ntfy_Server="${Ntfy_Server:=https://ntfy.sh}"
Ntfy_Name=""
Working_Dir="${Working_Dir:=$HOME/.local/var/$Prgnam}"
Defer_Files=""

# Function: Output usage
# Arguments: exit status
usage() (
  cat << EOF
  $Prgnam -- $Version

  Usage: [-v] [-s] [-n] [-d] url://rss.feed.xml

  Arguments:
  -v        Verbose logging
  -n        Namespace for ntfy.sh 
  -d        Working directory (Default: \$HOME/.local/var/$Prgnam)
  -s        ntfy.sh server url (Default: https://ntfy.sh)

EOF
exit "${1:-0}"
)

# Function: output strings to stdout
# Argument: string
out() {
  printf %s\\n "$*"
}

# Function: output log data to stderr
# Arguments: message
log() (
  if [ "$Verbose" -gt 0 ]; then
    printf '[%s]: %s\n' "$(date +'%Y-%m-%dT%H:%M:%S%z')" "$*" >&2
  fi
)

# Function: output error data to stderr
# Arguments: message
err() (
  printf '[%s]: ERROR %s\n' "$(date +'%Y-%m-%dT%H:%M:%S%z')" "$*" >&2
)

# Function: defer the removal of temp files for trap exit
# Argument: files to remove
defer() {
  # shellcheck disable=SC2068
  for file in $@; do
    Defer_Files="$(printf '%s\n' "$file" "$Defer_Files")"
  done
}

# Function: remove files at exit
clean_up() {
  for file in $Defer_Files; do
    rm -rf "$file"
  done
}

del_space() (
  # shellcheck disable=SC2086
  set -- $1
  while [ "$#" -gt 0 ]; do
    printf %s "$1"
    shift
  done
  printf \\n
)

# Function: output the checksum of a string
# Arguments: string
hash_sum() (
  if ! command -v cksum >/dev/null 2>&1; then
    printf "cksum not found in path\n"
    return 1
  fi

  if ! h="$(printf '%s' "$*" | cksum 2>&1)"; then
    printf %s\\n "$h"
    return 1
  fi
  a=${h%\ *}
  b=${h#*\ }

  printf %d\\n $((a + b)) 2>&1
)

# Function: make a curl request and return a file
# Arguments: Same as you would with curl, less -sS options
http__curl() (
  retval=0 response="" ret=""
  if ! command -v curl >/dev/null 2>&1; then
    printf 'curl not found in path\n'
    return 1
  fi

  if ! response=$(mktemp 2>&1); then
    printf %s\\n "$response"
    return 1
  fi

  if ! ret=$("$(command -v curl)" -sS \
    -o "$response" \
    -w '%{http_code}' \
    "$@" 2>&1); then
      rm -rf "$response"
      response="$ret"
      retval=1
  fi

  if [ $retval -eq 0 ] && [ "$ret" -ge 400 ]; then
    printf 'HTTP Error Code: %s\n' "$ret"
    return 1
  fi

  printf %s\\n "$response"
  return $retval
)

trap clean_up EXIT
main() {
  retval=0
  # Get opts
  while getopts 'vd:n:s:' opts; do
    case "$opts" in
      v) Verbose=$((Verbose + 1)) ;;
      d) Working_Dir="$OPTARG" ;;
      n) Ntfy_Name="$OPTARG" ;;
      s) Ntfy_Server="$OPTARG" ;;
      *) usage 1 ;;
    esac
  done
  shift "$((OPTIND - 1))"

  if [ -z "${1:-}" ]; then
    usage 1
  fi

  # shellcheck disable=2068
  for feed in $@; do
    if ! r="$(http__curl "$feed")"; then
      err "$r"
      retval=$((retval + 1))
      continue
    fi
    defer "$r"

    log "Parsing xml for $feed"

    feedName=""
    itemName=""
    itemLink=""
    item=0
    while read -r line; do
      # Get feed name (first title)
      if [ -z "$feedName" ]; then
        case "$line" in
          *\<title\>*)
            t="${line#*\<title\>}"
            feedName="${t%\<\/title\>*}"
            continue
            ;;
        esac
      fi

      if [ "$item" -ne 1 ]; then
        case "$line" in
          *\<item\>*)
            item=1
            continue
            ;;
        esac
      fi

      if [ "$item" -eq 1 ]; then
        case "$line" in
          *\<title\>*)
            t="${line#*\<title\>}"
            itemName="${t%\<\/title\>*}"
            continue
            ;;
          *\<link\>*)
            t="${line#*\<link\>}"
            itemLink="${t%\<\/link\>*}"
            continue
            ;;
          *\</item\>*) break ;;
          *) continue ;;
        esac
      fi
    done < "$r"

    if [ -z "$feedName" ] || [ -z "$itemName" ] || [ -z "$itemLink" ]; then
      err "Unable to parse RSS XML: $feed"
      retval=$((retval + 1))
      continue
    fi

    Ntfy_Name="${Ntfy_Name:-"$feedName"}"

    log "ntfy namespace: $Ntfy_Name"
    log "Name: $feedName"
    log "Title: $itemName"
    log "Link: $itemLink"


    # Hashed Ntfy_Name
    if ! h_name="$(hash_sum "$Ntfy_Name")"; then
      err "$h_name"
      return $((retval + 1))
    fi
    
    # Hashed Title
    if ! h_feed="$(hash_sum "$feedName")"; then
      err "$h_feed"
      return $((retval + 1))
    fi

    # Hashed Content
    if ! h_content="$(hash_sum "$feedName" "$itemName" "$itemLink")"; then
      err "$h_content"
      return $((retval + 1))
    fi

    hash_file="$Working_Dir/$h_name/$h_feed"
    if [ -r "$hash_file" ]; then
      if [ "$h_content" -eq "$(cat "$hash_file")" ]; then
        log "'$feedName' is at latest version. Skipping."
        continue
      fi
    fi

    log "'$feedName' has been updated"

    if ! mkdir -p "$(dirname "$hash_file")"; then
      err "FATAL Unable to access $hash_file"
      return $((retval + 1))
    fi

    if ! printf %s\\n "$h_content" > "$hash_file"; then
      err "FATAL Unable to write to $hash_file"
      return $((retval + 1))
    fi

    if ! ntfy_shortname="$(del_space "$Ntfy_Name")"; then
      err "Unable to shorten $Ntfy_Name for ntfy.sh; skipping"
      return $((retval + 1))
    fi

    log "Sending notification to $Ntfy_Server/$ntfy_shortname"
    if ! r="$(http__curl \
              "$Ntfy_Server/$ntfy_shortname" \
              -H "Title: $feedName" \
              -H "Click: $itemLink" \
              -H "Actions: view, Read, $itemLink" \
              -d "$itemName" )"; then
      err "$r"
      retval=$((retval + 1))
      continue
    fi
    defer "$r"

    out "Notification sent to: $Ntfy_Server/$ntfy_shortname"

  done
  return "$retval"
} 

main "$@"
