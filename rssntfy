#!/usr/bin/env sh
#
# BSD 2-Clause License
# 
# Copyright (c) 2023, Justin Teague
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, this
#    list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

# rssntfy -- send notifications to ntfy.sh service when an rss feed updates

set -eu

LC_ALL=C

Prgnam="$(basename "$0")"
Version=0.0.1
Ntfy_Server="${Ntfy_Server:=https://ntfy.sh}"
Ntfy_Name=""
Working_Dir="${Working_Dir:=$HOME/.local/var/$Prgnam}"
Defer_Files=""

Verbose=0
Test_Mode=0
# Function: Output usage
# Arguments: exit status
usage() (
  cat << EOF
  $Prgnam -- $Version

  Usage: [-tv] [OPTIONS] url://rss.feed.xml

  Arguments:
  -t        Testing mode (do not send to ntfy)
  -v        Verbose logging

  Options:
  -d        Working directory (Default: \$HOME/.local/var/$Prgnam)
  -n        Namespace for ntfy.sh (Optional)
  -s        ntfy.sh server url (Default: https://ntfy.sh)

  Example:
  To monitor 3 RSS feeds under one ntfy.sh namespace (e.g., RssNewsTechTag),
  set the following as as a cron job:

  $Prgnam -n RssNewsTechTag https://news.ycombinator.com/rss https://feeds.arstechnica.com/arstechnica/index https://www.theverge.com/rss/index.xml
  

EOF
exit "${1:-0}"
)

# Function: check if string is an integer
# Argument: string
is_int() {
  printf %d "$1" >/dev/null 2>&1
}

# Function: output strings to stdout
# Argument: string
out() {
  printf %s\\n "$*"
}

# Function: output log data to stderr
# Arguments: message
log() (
  priority=1
  if is_int "$1"; then
    priority="$1"
    shift
  fi

  if [ "$Verbose" -ge "$priority" ]; then
    printf '[%s]: %s\n' "$(date +'%Y-%m-%dT%H:%M:%S%z')" "$*" >&2
  fi
)

# Function: output error data to stderr
# Arguments: message
err() (
  printf '[%s]: ERROR %s\n' "$(date +'%Y-%m-%dT%H:%M:%S%z')" "$*" >&2
)

# Function: defer the removal of temp files for trap exit
# Argument: files to remove
defer() {
  # shellcheck disable=SC2068
  for file in $@; do
    Defer_Files="$(printf '%s\n' "$file" "$Defer_Files")"
  done
}

# Function: remove files at exit
clean_up() {
  for file in $Defer_Files; do
    rm -rf "$file"
  done
}

# Function: remove spaces from a string
# Argument: string
del_space() (
  # shellcheck disable=SC2086
  set -- $1
  while [ "$#" -gt 0 ]; do
    printf %s "$1"
    shift
  done
  printf \\n
)

# Function: output the checksum of a string
# Arguments: string
hash_sum() (
  hash=""
  if ! command -v cksum >/dev/null 2>&1; then
    printf "cksum not found in path\n"
    return 1
  fi

  if ! hash="$(printf '%s' "$*" | cksum 2>&1)"; then
    printf %s\\n "$hash"
    return 1
  fi
  a=${hash%\ *}
  b=${hash#*\ }
  hash=$((a + b))
  hash=$((hash + (hash << 6) + (hash << 16) - hash))

  printf %d\\n $hash 2>&1
)

# Function: make a curl request and return a file
# Arguments: Same as you would with curl, less -sS options
http__curl() (
  retval=0 response="" ret=""
  if ! command -v curl >/dev/null 2>&1; then
    printf 'curl not found in path\n'
    return 1
  fi

  if ! response=$(mktemp 2>&1); then
    printf %s\\n "$response"
    return 1
  fi

  if ! ret=$("$(command -v curl)" -sSL \
    -o "$response" \
    -w '%{http_code}' \
    "$@" 2>&1); then
      printf %s\\n "$ret" > "$response"
      retval=1
  fi

  if [ $retval -eq 0 ] && [ "$ret" -ge 400 ]; then
    printf 'HTTP Error Code: %s\n' "$ret"
    retval=1
  fi

  cat "$response"
  rm -rf "$response"
  return $retval
)

# Function: validate if xml+rss or html; attempts to return xml feed
# Arguments: URL
validate_xml() (
  if ! r="$(http__curl "$1")"; then
    printf %s\\n "$r"
    return 1
  fi

  # Check if xml feed
  case "$r" in
    \<\?xml\ version=*)
      printf %s\\n "$1"
      return
      ;;
  esac

  # Find xml href in HTML page
  r="${r%%\<\/head\>*}"

  case "$r" in
    *rss+xml*)
      rss="${r#*application/rss+xml\"*href=\"}"
      rss="${rss%%\"*}"
      case "$rss" in /*) xml="${1}$rss" ;; esac
      if rss="$(validate_xml "$rss")"; then
        printf %s\\n "$rss"
        return
      fi
      ;;
    *atom+xml*)
      atom="${r#*application/atom+xml\"*href=\"}"
      atom="${atom%%\"*}"
      case "$atom" in /*) atom="${1}$atom" ;; esac
      if atom="$(validate_xml "$atom")"; then
        printf %s\\n "$atom"
        return
      fi
      ;;
  esac
  
  # Not validated, sending back original with error
  printf %s\\n "$1"
  return 1
)

is_atom_feed() (
  case "$1" in
    *\<entry\>*) return 0 ;;
              *) return 1 ;;
  esac
)

main() {
  retval=0
  # Get opts
  while getopts 'vtd:n:s:' opts; do
    case "$opts" in
      t) Test_Mode=1 ;;
      v) Verbose=$((Verbose + 1)) ;;
      d) Working_Dir="$OPTARG" ;;
      n) Ntfy_Name="$OPTARG" ;;
      s) Ntfy_Server="$OPTARG" ;;
      *) usage 1 ;;
    esac
  done
  shift "$((OPTIND - 1))"

  if [ -z "${1:-}" ]; then
    usage 1
  fi

  # shellcheck disable=2068
  for feed in $@; do

    if ! feed="$(validate_xml "$feed")"; then
      err "Unable to validate $feed xml"
      retval=$((retval + 1))
      continue
    fi

    log 2 "Downloading $feed"
    # curl the feed
    if ! xml="$(http__curl "$feed")"; then
      err "Unable to download $feed"
      err "$xml"
      retval=$((retval + 1))
      continue
    fi

    log 2 "Parsing xml for $feed"
    feedName="" itemName="" itemLink=""
    if is_atom_feed "$xml"; then
      log 2 "I think $feed is an atom+xml feed"
      # Channel title
      # Strip everything after first entry tag
      xml="${xml%%\<\/entry\>*}"
      t="${xml%%\<\/title\>*}"
      feedName="${t#*\<title\>}"

      # First item title
      # Strip everything before first entry tag
      xml="${xml##*\<entry\>}"
      i="${xml%%\<\/title\>*}"
      itemName="${i#*\<title\>}"

      # First item link
      l="${xml%%\<\/link\>*}"
      l="${l#*\<link\>}"
      l="${l#*href=\"}"
      itemLink="${l%%\"*}"
    else
      log 2 "I think $feed is an rss+xml feed"
      # Parse RSS feed
      feedName="" itemName="" itemLink=""
      # Channel title
      # Strip everything after first item tag
      xml="${xml%%\<\/item\>*}"
      t="${xml%%\<\/title\>*}"
      feedName="${t#*\<title\>}"

      # First item title
      # Strip everything before first item tag
      xml="${xml##*\<item\>}"
      i="${xml%%\<\/title\>*}"
      itemName="${i#*\<title\>}"

      # First item link
      l="${xml%%\<\/link\>*}"
      itemLink="${l#*\<link\>}"
    fi

    # Check if it worked
    if [ -z "$feedName" ] || [ -z "$itemName" ] || [ -z "$itemLink" ]; then
      err "Unable to parse RSS XML: $feed"
      retval=$((retval + 1))
      continue
    fi

    Ntfy_Name="${Ntfy_Name:-"$(del_space "$feedName")"}"

    log 1 "ntfy namespace: $Ntfy_Name"
    log 1 "Name: $feedName"
    log 1 "Title: $itemName"
    log 1 "Link: $itemLink"

    # Hashed Ntfy_Name
    if ! h_name="$(hash_sum "$Ntfy_Name")"; then
      err "$h_name"
      return $((retval + 1))
    fi
    
    # Hashed Title
    if ! h_feed="$(hash_sum "$feedName")"; then
      err "$h_feed"
      return $((retval + 1))
    fi

    # Hashed Content
    if ! h_content="$(hash_sum "$feedName" "$itemName" "$itemLink")"; then
      err "Unable to hash content: $feedName, $itemName, $itemLink"
      err "$h_content"
      return $((retval + 1))
    fi

    hash_file="$Working_Dir/$h_name/$h_feed"
    if [ -r "$hash_file" ]; then
      if [ "$h_content" -eq "$(cat "$hash_file")" ]; then
        log "'$feedName' is at latest version. Skipping."
        continue
      fi
    fi

    log 1 "'$feedName' has been updated"

    if ! mkdir -p "$(dirname "$hash_file")"; then
      err "FATAL Unable to access $hash_file"
      return $((retval + 1))
    fi

    if ! printf %s\\n "$h_content" > "$hash_file"; then
      err "FATAL Unable to write to $hash_file"
      return $((retval + 1))
    fi

    log "$h_content saved to $hash_file"

    if ! ntfy_shortname="$(del_space "$Ntfy_Name")"; then
      err "Unable to shorten $Ntfy_Name for ntfy.sh; skipping"
      return $((retval + 1))
    fi

    # Check if this message is in ntfy cache
    if ! j="$(http__curl \
              "$Ntfy_Server/$ntfy_shortname/json?poll=1")"; then
      err "$j"
      retval=$((retval + 1))
      continue
    fi

    in_cache=0
    # Parse the ntfy json
    while read -r json; do
      cache_title="${json#*\"title\"\:\"}"
      cache_title="${cache_title%%\",*}"

      cache_msg="${json#*\"message\"\:\"}"
      cache_msg="${cache_msg%%\",*}"

      cache_url="${json#*\"url\"\:\"}"
      cache_url="${cache_url%%\"*}"

      if ! h_cache="$(hash_sum "$cache_title" "$cache_msg" "$cache_url")"; then
        err "$h_cache"
        return $((retval + 1))
      fi

      if [ "$h_cache" -eq "$(cat "$hash_file")" ]; then
        in_cache=1
        continue
      fi

      done << EOF
      $(printf %s\\n "$j")
EOF

    if [ "$in_cache" -eq 1 ]; then
      log "$feedName is already in the ntfy cache. Skipping."
      continue
    fi

    if [ "$Test_Mode" -ne 0 ]; then
      log "Test mode, not sending to ntfy."
      return
    fi

    log "Sending notification to $Ntfy_Server/$ntfy_shortname"
    if ! r="$(http__curl \
              "$Ntfy_Server/$ntfy_shortname" \
              -H "Title: $feedName" \
              -H "Click: $itemLink" \
              -H "Actions: view, Read, $itemLink" \
              -d "$itemName" )"; then
      err "$r"
      retval=$((retval + 1))
      continue
    fi

    log "Response from $Ntfy_Server: $r"

    out "Notification sent to: $Ntfy_Server/$ntfy_shortname"

  done
  return "$retval"
} 

trap clean_up EXIT
main "$@"
